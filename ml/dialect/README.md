# Dialect Translator


## 사용법
- run_train.py 를 실행한다
- run_translate.py를 실행한다.
- 결과를 감상한다.

- .data에 다른 tsv 파일을 넣어 학습시킬 수 있다.


## Phonemic_HMM

### 특수 토큰의 의미
- `'F'`상태의 의미
	- Deterministic finite state automaton의 accepting state와 같은 역할을 한다.
	- `'F'`를 가리키는 토큰은 **의미적 완성**이 이루어져 있을 가능성이 크다는 뜻으로, 문장을 끊고 다음 뒤에 이어지는 텍스트를 재귀로 처리할 적절한 위치를 결정한다.
	- 다음은 `'F'`토큰이 가져야 할 특성들이다:
		- (규칙 3) 이어지는 텍스트를 **매끄럽게** 만들기 위해 `symb` 및 `stat`이 공백으로 끝날 경우 그 다음은 `'F'`상태에 유도되어야 한다.
		- (규칙 5) 토큰이 길어질수록 `'F'`토큰으로 수렴할 가능성이 높아져야 한다. 구체적으로는, 공백의 개수가 클 수록 수렴가능성을 키운다.
		- 비터비 알고리즘에 따라 계산된 패스가 매끄럽지 않은 지점에서 `'F'`에 떨어지면 안된다. 이는 `get_state_path` 메소드 후반부 highest final state를 구하는 코드에서 구현하였다.

- `'failed'` 토큰의 의미
	- `util.py`의 `standardize`에 있다.
	- `dist_ratio`의 값이 0.7 이내로 들어오는 표준어 토큰을 찾지 못한 경우 표준화함수는 `'failed'`를 반환한다.
	- `'failed'`토큰을 부여받은 방언 토큰은 `_symbols`에 푸시되지 않는다.
	- `'failed'`토큰은 `_states`에 푸시되지 않는다.

- `'nowhere'` 토큰의 의미
	- `get_state_path` 메소드에서 이중 포문을 돌 때 `V[t,j] = V[t-1,i] * Ts(si->sj) * Op(sj->symb(t))`에 대해 `V == 0` 인 경우를 스킵하기 위한 장치.
	- 세 가지 가능성:
		- case (1) `Op(sj->symb(t)) == 0` (`j`만 가지고 배제 가능)
		- case (2) `V[t-1,i] == 0`
		- case (3) `Ts(si->sj) == 0`
	- `V[t,j]`와 `B[t,sj]`에 동시에 각각 1(-1+e300의 뜻을 가짐), `'nowhere'` 대입.

### 빈도 할당 규칙

__Rule 1.__
- 문장의 시작이거나 띄어쓰기로 분절된 지점에서 시작되는 토큰만 생각하기로 한다.

> 이 아래는 표준화된 방언 토큰을 필요로 하므로 표준화함수를 호출하고 `symb`과 `stat`를 선언한다.

__Rule 2.__
- 표준화 과정에서 `'failed'` 토큰이 부여된 방언 토큰을 폐기한다.
- 표준화 된 토큰의 길이가 7 이상으로 너무 길어지면 방언토큰과 함께 폐기한다.

> 이 아래는 토큰 폐기가 일어나지 않으므로 여기서 `_symbols`와 `_states`를 갱신한다.

__Rule 3.__
- 방언토큰이 공백으로 끝나거나 문장의 끝이라면, `T(S'->F)`와 `T(S->F)`와 `T(S->S')`에 점수 1을 준다.
	- `Ts(S->S')`는 규칙 4에 의해 한 번의 b 루프에서 점수 3을 받는다.
	- `Ts(S->F)`는 규칙 5에 의해 한 번의 b 루프에서 최소 점수 2 이상을 받는다.

__Rule 4.__
- 표준적인 HMM: `Op(S->O)`에 점수 1을 주고 `Ts(S'->S)`에 점수 2를 준다.

__Rule 5.__
- 표준화된 토큰에 공백이 들어가면, `Ts(S->F)`에 점수를 공백의 개수만큼 준다.
- 표준화된 토큰에 공백이 3개 존재하면, 점수를 준 후 b 루프를 벗어난다.
	- 따라서 공백이 토큰 중간에 3개 존재하는 표준어 토큰은 모두 배제된다.

__Rule 6.__
- 표준어 토큰과 일치하는 방언 토큰 O에 대하여 `Op(phon(O)->O)`에 매우 큰 점수를 준다.
- `phonemize(state)`를  `_symbols`에 푸시한다.

> `last`를 갱신한다.



## Phonemic_HMM.translate


### get_symb_path- 메소드

방언 텍스트 "마이 좀 주이소"를
	`["ma", "mai", "mai ", "mai jom" "mai jom ", "mai jom ju", "mai jom jui", "mai jom juiso"]`
로 변환.
만약 `self._symbols`에 인풋텍스트가 없다면 두 가지 아이디어로 근사 가능



### get_stat_path - 메소드

여기서 `Tr`과 `Op`는 스무딩(비록 MLE이지만 형식적으로라도) 후 로그값을 생각.
단, log0 = 1로 계산하여 양수값을 배제하는 식으로 if문 처리.


#### Thinning stage
- F가 아닌 state j에 대하여 모든 아웃풋이 죽는다면 states에서 j를 배제.
- 데이터가 크면 여기서만 몇분이 소요된다. 학습 시 `_states`의 크기를 줄여서 서브워드 토크나이즈 하고, 이진트리나 트라이나 딕트(해시)같은 자료구조로 저장할 필요가 있을 것이다. (미구현)


#### Prior stage
pi를 사용.
모든 i에 대하여 V[0,i]는 음수로 초기화

#### Viterbi stage

For each state `sj` at time `t`(ex. `symb(t) == "마이 좀"`):	
- If `V[t,j] = max_i V[t-1,i] + Ts(si->sj) + Op(sj->symb(t)) == -infty`: skip. 
	- 세 가지 가능성:
		- case (1) `Op(sj->symb(t)) == -infty` (`j`만 가지고 배제 가능)
		- case (2) `V[t-1,i] == -infty` (`i` loop)
		- case (3) `Ts(si->sj) == -infty` (`i` loop)
	- `V[t,j]`와 `B[t,sj]`에 각각 1, `'nowhere'` 대입.
	- 모든 i가 case (2) 또는 case (3)에 continue로 걸리면 `V[t,j] ==`
- Else: `V`와 `B` 갱신
만약 모든 sj!='F'가 nowhere를 가리키고 'F'가 'F'를 가리킨다면 문장을 끊어야 한다

`'F'`의 경우는 V의 계산이 다름 (find the highest probability final state 참조)
character n-gram cohesion score 이용.

끊겼다는 것은 그 타임 T에 V[T,i]가 모두 1로 죽었다는 것


한 음절씩 읽으면서 (음성유사도 사용해서 가장 가까운 트레인된 모델의 아웃풋 찾는다) 표준어토큰 패스가 길어지면서 생성된다(by 비터비).
표준어토큰 패스가 F에 도달하면 번역결과(=패스) 출력 후 재귀 써서 truncate된 다음 문장으로 넘어가기

시퀀스
	하, 하나, 하나바, 하나바께, 하나바께 업, 하나바께 업슴,...
가 사실 다음과 같은 히든 스테이트(표준어) 간의 패스
	하, 하나, 하나밖, 하나밖에, 하나밖에 없, 하나밖에 없습,...
에서 나왔다는 것을 추론



테스트
- 7/8 마이 좀 주이소 : 많이 좀 주십시오 o (3.74s)
- 7/8 집 배까티 나와 있슈 : 집 바깥에 나와 있 x (12.54s)
- 7/4 지벙 추마에 고두룸이 달리잖에유 : 지붕치에 고드름이 달리잖아유 x (38.18s)


